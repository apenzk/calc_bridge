import matplotlib.pyplot as plt

# Define the parameters for the calculation
swap_in_token_b = 0.03
iterations = 200
token_a_init = 0.9

class BridgeSystem:
    def __init__(self, token_a, invariant_type):
        self.token_a = token_a
        self.token_a_taken = 0  # Track total tokens taken out
        self.invariant_type = invariant_type

        if token_a > 1 or token_a < 0:
            raise ValueError("Token A must be between 0 and 1")

        if invariant_type == "sum":
            self.token_b = 1- self.token_a
        elif invariant_type == "prod":
            self.token_b = 0.25 / self.token_a

    def sum_invariant_swap(self, swap_in_token_b):
        """Performs a swap under the sum invariant constraint: token_A + token_B = 1"""
        swap_in_token_b
        # if token_a is negative just stop
        new_token_a = self.token_a - swap_in_token_b
        if new_token_a > 0:
            self.token_a = new_token_a
            self.token_b += swap_in_token_b
            self.token_a_taken += swap_in_token_b  # Track total token_a taken out
#        else: # do nothing

        
    def prod_invariant_swap(self, swap_in_token_b):
        """Performs a swap under the product invariant constraint: token_A * token_B = 0.25"""
#        (token_b + swap_in_token_b)*(token_a - swap_out_token_a) = 0.25
        swap_out_token_a = self.token_a - (0.25 / (self.token_b + swap_in_token_b) ) 
        new_token_a = self.token_a - swap_out_token_a

        if new_token_a > 0:
            self.token_a = new_token_a
            self.token_b += swap_in_token_b
            self.token_a_taken += swap_out_token_a

    def simulate_attack(self, swap_fraction=0.01, iterations=100):
        amounts_taken_out = []
        
        for _ in range(iterations):
            if self.invariant_type == "sum":
                self.sum_invariant_swap(swap_fraction)
            elif self.invariant_type == "prod":
                self.prod_invariant_swap(swap_fraction)
            amounts_taken_out.append(self.token_a_taken)  # Record cumulative swap amount
            
        return amounts_taken_out


# Simulate attack with sum invariant
pool = BridgeSystem(token_a=token_a_init, invariant_type="sum")
sum_invariant_results = pool.simulate_attack(swap_fraction=swap_in_token_b, iterations=iterations)

# Reset pool for product invariant simulation
pool = BridgeSystem(token_a=token_a_init, invariant_type="prod")
prod_invariant_results = pool.simulate_attack(swap_fraction=swap_in_token_b, iterations=iterations)

# Plotting
plt.figure(figsize=(10, 6))
plt.plot(range(1, iterations + 1), sum_invariant_results, label="Sum Invariant")#, marker='o')
plt.plot(range(1, iterations + 1), prod_invariant_results, label="Product Invariant")#, marker='x')
plt.xlabel("Iterations (Swap Steps)")
plt.ylabel("Cumulative Tokens A Taken Out of Pool")
plt.title(f"Bridge Exploit Calculation. Initial Token A: {token_a_init}")
plt.legend()
plt.grid(True)
# plt.show()
filename = f"./tokenA_init_{token_a_init}.png"
plt.savefig(filename)
